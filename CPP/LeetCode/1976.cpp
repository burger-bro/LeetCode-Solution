#include<iostream>
#include<vector>
#include<cassert>
#include<set>
#include<algorithm>
#include<unordered_map>
#include<string>
#include<sstream>
#include<deque>
#include<cmath>
#include <cstdio>
using namespace std;


class Solution {
    public:
        int countPaths(int n, vector<vector<int>>& roads) {
            cout << "begin" << endl;
            /*
            定义递归过程： cur.path_cnt = sum(min(path(cur.next)))
            */
            vector<vector<int>> map(n, vector<int>(n, 0));
            vector<vector<int>> valid_map(n, vector<int>(n, false));
            vector<pair<long long, long long>> dp(n, make_pair(-1, -1));
            // 这个map会导致循环，并且会出现非最小值的解
            for(auto road: roads){
                map[road[0]][road[1]] = road[2];
                map[road[1]][road[0]] = road[2];
            }
            buildDagMap(n, roads, valid_map);
            for(long long i=0;i<map.size();i++){
                for(long long j=0;j<map.size();j++){
                    cout << map[i][j] << " ";
                }
                cout << endl;
            }
            cout << endl;
            for(long long i=0;i<valid_map.size();i++){
                for(long long j=0;j<valid_map.size();j++){
                    cout << valid_map[i][j] << " ";
                }
                cout << endl;
            }

            pair<long long, long long> ret = dfs(0LL, map, valid_map, dp);
            cout << "ret: " << ret.second << endl;
            for(auto [k,v]:dp){
                cout << "dp" << v << endl;
            }
            return ret.second;
        }
        
        void buildDagMap(int n, vector<vector<int>>& roads, vector<vector<int>>& map){
            vector<vector<long long>> tmp_map(n, vector<long long>(n, 0));
            for(auto road: roads){
                tmp_map[road[0]][road[1]] = road[2];
                tmp_map[road[1]][road[0]] = road[2];
            }
            vector<bool> unvisited(n, true);
            vector<long long> dist(n, LONG_LONG_MAX);
            dist[0] = 0;
            unordered_map<int, vector<long long>> validEdges;
            for(long long i=0;i<n;i++){
                vector<long long> tmp;
                validEdges[i] = tmp;
            }
            for(long long i=0;i<n;i++){
                long long min = LONG_LONG_MAX, k;
                for(long long j=0;j<n;j++){
                    if(unvisited[j] && dist[j] < min){
                        min = dist[j];
                        k = j;
                    }
                }
                unvisited[k] = false;
                for(long long j=0;j<n;j++){
                    if(tmp_map[k][j] == 0) continue;
                    long long tmp = dist[k]+tmp_map[k][j];
                    if(tmp<dist[j]){
                        // validEdges[j].clear();
                        validEdges[j].push_back(k);
                        dist[j] = dist[k]+tmp_map[k][j];
                    }else if(tmp==dist[j]){
                        validEdges[j].push_back(k);
                    }
                }
            }
            for(auto[k,v]:validEdges){
                for(auto j:v){
                    map[j][k] = true;
                }
            }
        }

        pair<long long, long long> dfs(int cur, vector<vector<int>>& map, vector<vector<int>>& valid_map, vector<pair<long long, long long>>& dp){
            if(dp[cur].first != -1) return dp[cur];
            if(cur == map.size()-1) return make_pair(0, 1);
            cout << "cur:" << cur << endl;
            unordered_map<unsigned long long, long long> min2Cnt;
            bool visit = false;
            for(int i=0;i<map.size();i++){
                if(map[cur][i]==0 || !valid_map[cur][i]) continue;
                visit = true;
                unsigned long long tmp = map[cur][i];
                map[cur][i] = -1;
                map[i][cur] = -1;
                auto pp = dfs(i, map, valid_map, dp);
                min2Cnt[pp.first+tmp] += (unsigned long long)pp.second;
                min2Cnt[pp.first+tmp] %= (long long)pow(10, 9)+7;
                map[cur][i] = tmp;
                map[i][cur] = tmp;
            }
            if(!visit) return make_pair(0, 0);
            long long curPathCnt, curMin=LONG_LONG_MAX;
            for(auto [k, v]: min2Cnt){
                if(v == 0) continue; // 非常关键的一行，如果路径不可达，即便cost很小也要舍去
                if(k<curMin){
                    curMin = k;
                    curPathCnt = v;
                }
            }
            pair<long long, long long> r=make_pair(curMin, curPathCnt);
            dp[cur] = r;
            // cout << "cur:" << cur << " curMin:" << curMin << " curPathCnt:" << curPathCnt <<  endl;
            return r;
        }
    };

int main(void){
    Solution s;
    vector<vector<int>> edges;
    int n, res, ans;
    // case bug2
    n = 19;
    edges = {{1,0,7714},{2,1,6248},{2,0,13962},{3,1,14818},{3,0,22532},{3,2,8570},{3,4,9230},{5,4,1241},{5,0,33003},{5,2,19041},{5,1,25289},{5,3,10471},{1,6,33307},{4,6,9259},{3,7,20212},{5,7,9741},{6,7,1723},{4,7,10982},{7,0,42744},{8,4,12772},{8,6,3513},{8,0,44534},{8,2,30572},{1,8,36820},{8,7,1790},{8,3,22002},{9,6,13145},{9,5,21163},{8,9,9632},{9,4,22404},{9,7,11422},{9,1,46452},{9,2,40204},{10,8,6014},{10,4,18786},{9,11,3472},{11,7,14894},{6,11,16617},{4,11,25876},{0,11,57638},{11,2,43676},{11,5,24635},{2,12,50515},{3,12,41945},{12,6,23456},{12,8,19943},{10,12,13929},{12,1,56763},{12,0,64477},{12,11,6839},{5,12,31474},{12,4,32715},{12,13,1401},{13,10,15330},{8,13,21344},{4,13,34116},{13,1,58164},{3,13,43346},{9,13,11712},{13,0,65878},{13,11,8240},{13,7,23134},{11,14,10467},{13,14,2227},{14,12,3628},{14,1,60391},{14,5,35102},{10,14,17557},{14,4,36343},{14,0,68105},{14,7,25361},{8,14,23571},{6,14,27084},{14,3,45573},{14,2,54143},{14,9,13939},{15,6,35506},{7,15,33783},{15,14,8422},{15,5,43524},{16,7,4344},{16,1,39374},{0,16,47088},{8,16,2554},{0,17,77829},{17,4,46067},{8,17,33295},{17,6,36808},{17,11,20191},{17,10,27281},{17,1,70115},{16,17,30741},{14,17,9724},{15,17,1302},{7,17,35085},{18,3,57742},{18,12,15797},{18,7,37530},{18,15,3747},{14,18,12169},{18,5,47271},{18,9,26108}};
    res = s.countPaths(n, edges);
    cout << "res" << res << endl;
    ans = 2974;
    assert(res == ans);
    // case bug
    n = 29;
    edges = {{1,0,7443},{2,1,9509},{3,2,8933},{4,3,2714},{2,4,11647},{3,5,8349},{5,0,34234},{6,4,584},{0,6,29183},{3,6,3298},{6,2,12231},{1,6,21740},{3,7,2990},{5,8,7837},{1,8,34628},{6,8,12888},{0,8,42071},{9,8,1650},{4,9,15122},{9,7,14846},{9,5,9487},{9,1,36278},{6,9,14538},{9,3,17836},{1,10,23672},{10,7,2240},{10,4,2516},{7,11,20638},{10,11,18398},{4,11,20914},{11,9,5792},{11,2,32561},{3,11,23628},{1,11,42070},{8,11,7442},{5,11,15279},{11,6,20330},{12,0,54359},{12,2,37407},{12,8,12288},{12,4,25760},{12,10,23244},{11,12,4846},{9,12,10638},{13,5,21367},{13,1,48158},{11,13,6088},{13,2,38649},{9,13,11880},{7,13,26726},{13,4,27002},{13,3,29716},{6,13,26418},{8,13,13530},{13,12,1242},{13,0,55601},{13,10,24486},{14,3,32382},{14,11,8754},{14,7,29392},{8,14,16196},{15,11,7583},{10,15,25981},{14,16,8258},{16,3,40640},{10,16,35410},{16,12,12166},{8,16,24454},{16,4,37926},{5,16,32291},{16,2,49573},{9,17,30859},{17,13,18979},{3,17,48695},{17,11,25067},{17,16,8055},{17,10,43465},{17,8,32509},{5,17,40346},{1,17,67137},{4,17,45981},{15,17,17484},{17,6,45397},{18,15,1705},{10,18,27686},{4,18,30202},{18,6,29618},{18,9,15080},{19,0,67141},{18,19,8340},{7,19,38266},{19,2,50189},{9,20,37879},{4,20,53001},{18,20,22799},{20,14,23333},{17,20,7020},{0,20,81600},{20,12,27241},{20,13,25999},{3,20,55715},{2,20,64648},{11,21,34704},{13,21,28616},{20,21,2617},{7,21,55342},{21,17,9637},{21,4,55618},{21,0,84217},{21,12,29858},{2,21,67265},{21,9,40496},{21,5,49983},{16,21,17692},{21,6,55034},{21,3,58332},{15,21,27121},{8,21,42146},{10,21,53102},{21,19,17076},{22,5,52055},{1,22,78846},{8,22,44218},{22,0,86289},{2,22,69337},{16,22,19764},{12,22,31930},{22,11,36776},{10,22,55174},{14,22,28022},{3,22,60404},{22,20,4689},{22,6,57106},{15,22,29193},{8,23,53441},{23,1,88069},{23,19,28371},{23,22,9223},{14,23,37245},{6,23,66329},{7,23,66637},{0,23,95512},{5,23,61278},{23,18,36711},{23,20,13912},{23,15,38416},{3,23,69627},{23,13,39911},{9,23,51791},{24,23,2196},{24,4,69109},{24,14,39441},{24,1,90265},{24,22,11419},{3,24,71823},{20,25,18955},{25,8,58484},{4,25,71956},{13,25,44954},{25,24,2847},{25,21,16338},{25,7,71680},{3,25,74670},{12,25,46196},{25,10,69440},{25,23,5043},{25,1,93112},{25,9,56834},{19,25,33414},{25,22,14266},{18,25,41754},{25,15,43459},{2,25,83603},{6,25,71372},{11,25,51042},{26,22,17573},{26,0,103862},{26,7,74987},{26,3,77977},{21,26,19645},{26,12,49503},{25,26,3307},{8,26,61791},{26,18,45061},{24,26,6154},{26,5,69628},{16,26,37337},{26,10,72747},{26,1,96419},{26,13,48261},{6,26,74679},{26,15,46766},{9,26,60141},{14,26,45595},{17,26,29282},{26,20,22262},{23,26,8350},{4,26,75263},{26,19,36721},{26,2,86910},{27,25,4616},{27,8,63100},{27,24,7463},{15,27,48075},{14,27,46904},{27,3,79286},{27,2,88219},{28,1,103845},{28,25,10733},{16,28,44763},{28,3,85403},{28,14,53021},{7,28,82413},{27,28,6117},{15,28,54192},{28,5,77054},{6,28,82105},{28,8,69217},{24,28,13580},{2,28,94336},{10,28,80173},{28,26,7426},{28,22,24999},{28,11,61775},{28,19,44147},{28,23,15776},{28,12,56929},{28,13,55687},{4,28,82689}};
    res = s.countPaths(n, edges);
    cout << "res" << res << endl;
    ans = 66275;
    assert(res == ans);
    // case std1
    n = 7;
    edges = {{0,6,7},{0,1,2},{1,2,3},{1,3,3},{6,3,3},{3,5,1},{6,5,1},{2,5,1},{0,4,5},{4,6,2}};
    res = s.countPaths(n, edges);
    cout << "res" << res << endl;
    ans = 4;
    assert(res == ans);
    // case std2
    n = 2;
    edges = {{0,1,10}};
    res = s.countPaths(n, edges);
    cout << "res" << res << endl;
    ans = 1;
    assert(res == ans);
}
            
    
